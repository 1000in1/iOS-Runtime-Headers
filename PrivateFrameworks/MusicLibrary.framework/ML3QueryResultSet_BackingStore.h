/* Generated by RuntimeBrowser
   Image: /System/Library/PrivateFrameworks/MusicLibrary.framework/MusicLibrary
 */

/* RuntimeBrowser encountered an ivar type encoding it does not handle. 
   See Warning(s) below.
 */

@class NSObject<OS_dispatch_queue>, countData;

@interface ML3QueryResultSet_BackingStore : NSObject {
    NSObject<OS_dispatch_queue> *_backingStoreQueue;
    long long _backwardCursorIdx;

  /* Error parsing encoded ivar type info: {?="persistentID"q"section"C"data"(ResultData="propertyData"^@"countData"{CountData="trackCount"I"subCollectionCount"I})"callback"@?} */
    struct { 
        long long persistentID; 
        unsigned char section; 
        /* Warning: unhandled union encoding: '(ResultData="propertyData"^@"countData"{CountData="trackCount"I"subCollectionCount"I})"callback"@?}' */ union ResultData { 
            countData **propertyData; 
        } data; 
        id callback; 
    } _backwardResult;

    bool _cancelled;
    bool _finishedLoading;
    long long _forwardCursorIdx;

  /* Error parsing encoded ivar type info: {?="persistentID"q"section"C"data"(ResultData="propertyData"^@"countData"{CountData="trackCount"I"subCollectionCount"I})"callback"@?} */
    struct { 
        long long persistentID; 
        unsigned char section; 
        /* Warning: unhandled union encoding: '(ResultData="propertyData"^@"countData"{CountData="trackCount"I"subCollectionCount"I})"callback"@?}' */ union ResultData { 
            countData **propertyData; 
        } data; 
        id callback; 
    } _forwardResult;

    struct vector<ML3QueryResult, std::__1::allocator<ML3QueryResult> > { 
        struct { /* ? */ } *__begin_; 
        struct { /* ? */ } *__end_; 
        struct __compressed_pair<ML3QueryResult *, std::__1::allocator<ML3QueryResult> > { 
            struct { /* ? */ } *__first_; 
        } __end_cap_; 
    } _results;
    long long _sectionEndIdx;
    long long _sectionStartIdx;
    unsigned long _size;
}

@property(readonly) unsigned long count;

- (id).cxx_construct;
- (void).cxx_destruct;
- (id)backingStoreByRemovingPersistentIDs:(const struct unordered_set<long long, std::__1::hash<long long>, std::__1::equal_to<long long>, std::__1::allocator<long long> > { struct __hash_table<long long, std::__1::hash<long long>, std::__1::equal_to<long long>, std::__1::allocator<long long> > { struct unique_ptr<std::__1::__hash_node<long long, void *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<long long, void *> *> > > { struct __compressed_pair<std::__1::__hash_node<long long, void *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<long long, void *> *> > > { struct __hash_node<long long, void *> {} **x_1_3_1; struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<long long, void *> *> > { struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node<long long, void *> *> > { unsigned long x_1_5_1; } x_2_4_1; } x_1_3_2; } x_1_2_1; } x_1_1_1; struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<long long, void *> *>, std::__1::allocator<std::__1::__hash_node<long long, void *> > > { struct __hash_node_base<std::__1::__hash_node<long long, void *> *> { struct __hash_node<long long, void *> {} *x_1_3_1; } x_2_2_1; } x_1_1_2; struct __compressed_pair<unsigned long, std::__1::hash<long long> > { unsigned long x_3_2_1; } x_1_1_3; struct __compressed_pair<float, std::__1::equal_to<long long> > { float x_4_2_1; } x_1_1_4; } x1; }*)arg1;
- (void)cancel;
- (BOOL)containsPersistentIDs:(const struct unordered_set<long long, std::__1::hash<long long>, std::__1::equal_to<long long>, std::__1::allocator<long long> > { struct __hash_table<long long, std::__1::hash<long long>, std::__1::equal_to<long long>, std::__1::allocator<long long> > { struct unique_ptr<std::__1::__hash_node<long long, void *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<long long, void *> *> > > { struct __compressed_pair<std::__1::__hash_node<long long, void *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<long long, void *> *> > > { struct __hash_node<long long, void *> {} **x_1_3_1; struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<long long, void *> *> > { struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node<long long, void *> *> > { unsigned long x_1_5_1; } x_2_4_1; } x_1_3_2; } x_1_2_1; } x_1_1_1; struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<long long, void *> *>, std::__1::allocator<std::__1::__hash_node<long long, void *> > > { struct __hash_node_base<std::__1::__hash_node<long long, void *> *> { struct __hash_node<long long, void *> {} *x_1_3_1; } x_2_2_1; } x_1_1_2; struct __compressed_pair<unsigned long, std::__1::hash<long long> > { unsigned long x_3_2_1; } x_1_1_3; struct __compressed_pair<float, std::__1::equal_to<long long> > { float x_4_2_1; } x_1_1_4; } x1; }*)arg1;
- (unsigned long)count;
- (void)dealloc;
- (void)enumerateResultsUsingBlock:(id)arg1;
- (void)enumerateSectionsUsingBlock:(id)arg1;
- (id)initWithSize:(unsigned long)arg1;
- (id)resultAtIndex:(unsigned long)arg1;
- (void)reverseEnumerateResultsUsingBlock:(id)arg1;
- (void)reverseEnumerateSectionsUsingBlock:(id)arg1;

@end
